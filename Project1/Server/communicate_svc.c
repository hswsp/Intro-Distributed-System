/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */
#include "communicate.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h> //memset
#include <time.h>
#include <rpc/pmap_clnt.h>

#include <memory.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/ioctl.h>
#include <net/if.h>


#include "client.h"
#include "subscribe.h"
#include <string>
#include <iostream>
#include "stringTokenizer.h"
using namespace std;

#ifndef SIG_PF
#define SIG_PF void(*)(int)
#endif

//#define SERVER "127.0.0.1"
#define BUFLEN 512	//Max length of buffer
#define PORT 5105	//The port on which to send register info
#define HBPORT 8888
#define NUM_SERVER 1
list<ClientInfo> g_clientList;
list<ClientInfo> g_serverList;
char *serverIP;

static bool_t *
_join_1 (join_1_argument *argp, struct svc_req *rqstp)
{
	return (join_1_svc(argp->IP, argp->Port, rqstp));
}

static bool_t *
_leave_1 (leave_1_argument *argp, struct svc_req *rqstp)
{
	return (leave_1_svc(argp->IP, argp->Port, rqstp));
}

static bool_t *
_subscribe_1 (subscribe_1_argument *argp, struct svc_req *rqstp)
{
	return (subscribe_1_svc(argp->IP, argp->Port, argp->Article, rqstp));
}

static bool_t *
_unsubscribe_1 (unsubscribe_1_argument *argp, struct svc_req *rqstp)
{
	return (unsubscribe_1_svc(argp->IP, argp->Port, argp->Article, rqstp));
}

static bool_t *
_publish_1 (publish_1_argument *argp, struct svc_req *rqstp)
{
	return (publish_1_svc(argp->Article, argp->IP, argp->Port, rqstp));
}

static bool_t *
_ping_1 (void  *argp, struct svc_req *rqstp)
{
	return (ping_1_svc(rqstp));
}

static void
communicate_prog_1(struct svc_req *rqstp, register SVCXPRT *transp)
{
	union {
		join_1_argument join_1_arg;
		leave_1_argument leave_1_arg;
		subscribe_1_argument subscribe_1_arg;
		unsubscribe_1_argument unsubscribe_1_arg;
		publish_1_argument publish_1_arg;
	} argument;
	char *result;
	xdrproc_t _xdr_argument, _xdr_result;
	char *(*local)(char *, struct svc_req *);

	switch (rqstp->rq_proc) {
	case NULLPROC:
		(void) svc_sendreply (transp, (xdrproc_t) xdr_void, (char *)NULL);
		return;

	case Join:
		_xdr_argument = (xdrproc_t) xdr_join_1_argument;
		_xdr_result = (xdrproc_t) xdr_bool;
		local = (char *(*)(char *, struct svc_req *)) _join_1;
		break;

	case Leave:
		_xdr_argument = (xdrproc_t) xdr_leave_1_argument;
		_xdr_result = (xdrproc_t) xdr_bool;
		local = (char *(*)(char *, struct svc_req *)) _leave_1;
		break;

	case Subscribe:
		_xdr_argument = (xdrproc_t) xdr_subscribe_1_argument;
		_xdr_result = (xdrproc_t) xdr_bool;
		local = (char *(*)(char *, struct svc_req *)) _subscribe_1;
		break;

	case Unsubscribe:
		_xdr_argument = (xdrproc_t) xdr_unsubscribe_1_argument;
		_xdr_result = (xdrproc_t) xdr_bool;
		local = (char *(*)(char *, struct svc_req *)) _unsubscribe_1;
		break;

	case Publish:
		_xdr_argument = (xdrproc_t) xdr_publish_1_argument;
		_xdr_result = (xdrproc_t) xdr_bool;
		local = (char *(*)(char *, struct svc_req *)) _publish_1;
		break;

	case Ping:
		_xdr_argument = (xdrproc_t) xdr_void;
		_xdr_result = (xdrproc_t) xdr_bool;
		local = (char *(*)(char *, struct svc_req *)) _ping_1;
		break;

	default:
		svcerr_noproc (transp);
		return;
	}
	memset ((char *)&argument, 0, sizeof (argument));
	if (!svc_getargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
		svcerr_decode (transp);
		return;
	}
	result = (*local)((char *)&argument, rqstp);
	if (result != NULL && !svc_sendreply(transp, (xdrproc_t) _xdr_result, result)) {
		svcerr_systemerr (transp);
	}
	if (!svc_freeargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
		fprintf (stderr, "%s", "unable to free arguments");
		exit (1);
	}
	return;
}

void die(const char* s)
{
	perror(s);
	exit(1);
}

char* checkip()
{
    char* ip_address = new char[32];
    int fd;
    struct ifreq ifr;
     
    /*AF_INET - to define network interface IPv4*/
    /*Creating soket for it.*/
    fd = socket(AF_INET, SOCK_DGRAM, 0);
     
    /*AF_INET - to define IPv4 Address type.*/
    ifr.ifr_addr.sa_family = AF_INET;
     
    /*eth0 - define the ifr_name - port name
    where network attached.*/
    memcpy(ifr.ifr_name, "eno1", IFNAMSIZ-1);
     
    /*Accessing network interface information by
    passing address using ioctl.*/
    ioctl(fd, SIOCGIFADDR, &ifr);
    /*closing fd*/
    close(fd);
     
    /*Extract IP Address*/
    strcpy(ip_address,(inet_ntoa(((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr)));
    return ip_address;//
}

void * heartBeat(void * pData)
{
	struct sockaddr_in si_me, si_other;
	int s,  recv_len;
	socklen_t slen= sizeof(si_other);
	char buf[BUFLEN];
	bool * Is_live = (bool*) pData;
	//create a UDP socket
	if ((s=socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1)
	{
		die("socket");
	}
	
	// zero out the structure
	memset((char *) &si_me, 0, sizeof(si_me));
	
	si_me.sin_family = AF_INET;
	si_me.sin_port = htons(HBPORT);
	si_me.sin_addr.s_addr = htonl(INADDR_ANY);
	
	//bind socket to port
	if( bind(s , (struct sockaddr*)&si_me, sizeof(si_me) ) == -1)
	{
		die("bind");
	}
	//keep listening for data
	//wait list 10 sec.
	timeval tv;
	tv.tv_sec  = 10;
	tv.tv_usec = 0;
	while(1)
	{
		fflush(stdout);
		//Set Timeout for recv call
		setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, reinterpret_cast<char*>(&tv), sizeof(timeval));
		//try to receive some data, this is a blocking call
		if ((recv_len = recvfrom(s, buf, BUFLEN, 0, (struct sockaddr *) &si_other, &slen)) == -1)
		{
			if(*Is_live)
			{
				continue;
			}
			else
			{
				die("recvfrom()");
			}
		}
	#ifdef	DEBUG	/* DEBUG */	
		//print details of the client/peer and the data received
		printf("Received packet from %s:%d\n", inet_ntoa(si_other.sin_addr), ntohs(si_other.sin_port));
		printf("Data: %s\n" , buf);	
	#endif	
		//now reply the client with the same data
		if (sendto(s, buf, recv_len, 0, (struct sockaddr*) &si_other, slen) == -1)
		{
			die("sendto()");
		}
	}
	close(s);
	pthread_exit(NULL);
}

int Register(const char* SERVER)
{
	struct sockaddr_in si_other;
	int s, i;
	socklen_t slen= sizeof(si_other);
	char message[BUFLEN];
    char* ip_address;

	if ( (s=socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1)
	{
		die("socket");
	}

	memset((char *) &si_other, 0, sizeof(si_other));
	si_other.sin_family = AF_INET;
	si_other.sin_port = htons(PORT);
	
	if (inet_aton(SERVER , &si_other.sin_addr) == 0) 
	{
		fprintf(stderr, "inet_aton() failed\n");
		exit(1);
	}

    ip_address = checkip();
	printf("The ip address of this group server is %s\n",ip_address);
	sprintf(message,"Register;RPC;%s;%d;%x;%u", ip_address,HBPORT,12345678,1);//[“Register;RPC;IP;Port;ProgramID;Version”]
	printf("Register to super server.......\n");
	//wait list 5 sec.
	timeval tv;
	tv.tv_sec  = 5;
	tv.tv_usec = 0;
	//Set Timeout for recv call
	setsockopt(s, SOL_SOCKET, SO_SNDTIMEO, reinterpret_cast<char*>(&tv), sizeof(timeval));
	if (sendto(s, message, strlen(message) , 0 , (struct sockaddr *) &si_other, slen)==-1)
	{
		perror("sendto()");
	    return -1;
	}

	close(s);
	return 0;
}

list<ClientInfo>::iterator findServer(string strIPAddress)
{
	list<ClientInfo>::iterator it;

	for(it=g_serverList.begin();it!=g_serverList.end();it++)
    {
		if(strIPAddress.compare(it->m_szIPAddress) == 0)
		{
			return it;
		}
	}

	return g_serverList.end();
}

//print all clients connected to this group server
void print_clients()
{
	list<ClientInfo>::iterator it;
	int nIndex = 1;
	cout << "------------------------------------------" << endl;
	cout << "-- active clients List " << endl;
	for(it=g_clientList.begin();it!=g_clientList.end();it++)
    {
		cout << "-- " << nIndex++ << ". " << it->m_szIPAddress << "  : " << it-> m_nPort << endl;
	}
	cout << "------------------------------------------" << endl;
}
void GetList (const char* SERVER)
{
	struct sockaddr_in si_other;
	int s, recv_len;
	socklen_t slen= sizeof(si_other);
	char message[BUFLEN];
    char* ip_address;

	
	if ( (s=socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1)
	{
		die("socket");
	}

	memset((char *) &si_other, 0, sizeof(si_other));
	si_other.sin_family = AF_INET;
	si_other.sin_port = htons(PORT);
	
	if (inet_aton(SERVER , &si_other.sin_addr) == 0) 
	{
		fprintf(stderr, "inet_aton() failed\n");
		exit(1);
	}

    ip_address = checkip();
	
	sprintf(message,"GetList;RPC;%s;%d", ip_address,HBPORT);//[“GetList;RPC;IP;Port”]
	//send the message
	if (sendto(s, message, strlen(message) , 0 , (struct sockaddr *) &si_other, slen)==-1)
	{
		die("sendto()");
	}
	printf("GetList from super server.......\n");
	//wait list 2 sec.
	timeval tv;
	tv.tv_sec  = 2;
	tv.tv_usec = 0;
	setsockopt(s, SOL_SOCKET, SO_RCVTIMEO, reinterpret_cast<char*>(&tv), sizeof(timeval));
	//try to receive some data, this is a blocking call
	recv_len = recvfrom(s, message, BUFLEN, 0, (struct sockaddr *) &si_other, &slen);
	if (recv_len == -1)
	{
		die("recvfrom()");
	}
	message[recv_len] = '\0';
	//print details of the client/peer and the data received
	printf("Received packet from super server %s:%d\n", inet_ntoa(si_other.sin_addr), ntohs(si_other.sin_port));
	
	//Tokenizer
	cout << "------------------------------------------" << endl;
	cout << "-- active servers List " << endl;
	//Parsing Address port Info
	CStringTokenizer stringTokenizer;
	stringTokenizer.Split(message, ";");
	int nIndex = 1;
	string strIPAddress,ProgramID,Version;
	g_serverList.erase(g_serverList.begin(),g_serverList.end());//clear list
	while(1)
	{
		if((strIPAddress = stringTokenizer.GetNext())=="")
		{
			break;
		}
		ProgramID = stringTokenizer.GetNext();
		Version = stringTokenizer.GetNext();
		//store info
		if(findServer(strIPAddress) == g_serverList.end())
		{
			ClientInfo info;
			strcpy(info.m_szIPAddress, strIPAddress.c_str());
			//info.m_uiProgram = atol(ProgramID.c_str());
			//info.m_uiVersion = atol(Version.c_str());
			g_serverList.push_back(info);
		}
		cout << "-- " << nIndex++ << ". " << strIPAddress << endl;//<< " Program : " << ProgramID << " Ver : " << Version
	}
	cout << "------------------------------------------" << endl;
	
	close(s);
	return;
}
void Deregister(const char* SERVER,bool& Is_live)
{
	struct sockaddr_in si_other;
	int s;
	socklen_t slen= sizeof(si_other);
	char message[BUFLEN];
    char* ip_address;

	if ( (s=socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) == -1)
	{
		die("socket");
	}

	memset((char *) &si_other, 0, sizeof(si_other));
	si_other.sin_family = AF_INET;
	si_other.sin_port = htons(PORT);
	
	if (inet_aton(SERVER , &si_other.sin_addr) == 0) 
	{
		fprintf(stderr, "inet_aton() failed\n");
		exit(1);
	}

    ip_address = checkip();
	sprintf(message,"Deregister;RPC;%s;%d", ip_address,HBPORT);//[“Deregister;RPC;IP;Port”]
	printf("Deregister from super server.......\n");
	//send the message
	if (sendto(s, message, strlen(message) , 0 , (struct sockaddr *) &si_other, slen)==-1)
	{
		die("sendto()");
	}
	close(s);

	Is_live = false;

	return;
}

void* Command(void * pData)
{
	char szUserInput[512];
	bool * Is_live = (bool*) pData;
	printf("\nInstructions:\n");    
	printf("listC: show all clients connected to this group server\n");  
	printf("listS: Show all alive servers in this group\n");   
	printf("Deregister: leave from the register server\n");
	while(* Is_live)
	{
		printf("Instruction:\n listC / listS / Deregister\n");
		cin.getline(szUserInput, 512);

		if(strcmp(szUserInput, "Deregister") == 0)
		{
			Deregister(serverIP,*Is_live);
			break;
		}
		else if(strcmp(szUserInput, "listS") == 0)
		{
			GetList (serverIP);
		}
		else if(strcmp(szUserInput, "listC") == 0)
		{
			print_clients();
		}
		else
		{
			system(szUserInput);
		}
	}
	pthread_exit(NULL);
}


int main (int argc, char **argv)
{
	bool Is_servers_live[NUM_SERVER] = {true};
    //pthread_t unicast_thread;
	pthread_t heartBeatThread;
	pthread_t command_thread;
    if (argc != 2) {
     fprintf(stderr, "usage: %s host message\n", argv[0]);
     exit(1);
    }
    serverIP = argv[1];
	int suc_re = Register(serverIP);
	if(suc_re<0)
	{
		cout << "fail registering to super server." << endl;
		return -1;
	}
	cout << "Group-server starts." << endl;
	//heart beat. 
	pthread_create(&heartBeatThread, NULL, heartBeat, (void*)&Is_servers_live[0]);
	pthread_create(&command_thread, NULL, Command, (void*)&Is_servers_live[0]);

	//RPC set
	register SVCXPRT *transp;

	pmap_unset (COMMUNICATE_PROG, COMMUNICATE_VERSION);

	transp = svcudp_create(RPC_ANYSOCK);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create udp service.");
		exit(1);
	}
	if (!svc_register(transp, COMMUNICATE_PROG, COMMUNICATE_VERSION, communicate_prog_1, IPPROTO_UDP)) {
		fprintf (stderr, "%s", "unable to register (COMMUNICATE_PROG, COMMUNICATE_VERSION, udp).");
		exit(1);
	}

	transp = svctcp_create(RPC_ANYSOCK, 0, 0);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create tcp service.");
		exit(1);
	}
	if (!svc_register(transp, COMMUNICATE_PROG, COMMUNICATE_VERSION, communicate_prog_1, IPPROTO_TCP)) {
		fprintf (stderr, "%s", "unable to register (COMMUNICATE_PROG, COMMUNICATE_VERSION, tcp).");
		exit(1);
	}
	
	//Listen to client
	//pthread_create(&unicast_thread, NULL, unicast, (void*)&Is_servers_live[0]);
	svc_run ();
	int nRes = pthread_join(heartBeatThread, NULL);
	nRes = pthread_join(command_thread, NULL);
	//nRes = pthread_join(unicast_thread, NULL);
	fprintf (stderr, "%s", "svc_run returned");
	exit (1);
	/* NOTREACHED */
}
